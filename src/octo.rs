use octocrab::{models::issues::Issue, Octocrab};
use std::env;

pub async fn create_dataset_report_issue(
    repo_owner: &str,
    repo_name: &str,
    markdown_header: String,
    markdown_rows: Vec<String>,
) -> anyhow::Result<()> {
    let issue_title = "Observability: Attribute names can be improved";
    let mut markdown_header = markdown_header;
    markdown_header.push_str(
        "This report was generated by [honey-health](https://github.com/jerbly/honey-health). \
                The table shows columns found in the dataset without matching semantic conventions. \
                This _could_ be an indication of data quality issues. \
                Suggestions are given to help improve these attributes.\n\n \
                [\"Effective trace instrumentation with semantic conventions\"](https://www.honeycomb.io/blog/effective-trace-instrumentation-semantic-conventions) \
                may help you improve your instrumentation.\n\n \
                _Note: If the report is too large, it will been split into multiple comments._\n\n",
    );

    create_table_issue(
        repo_owner,
        repo_name,
        markdown_header,
        markdown_rows,
        issue_title,
    )
    .await
}

pub async fn create_enum_report_issue(
    repo_owner: &str,
    repo_name: &str,
    markdown_header: String,
    markdown_rows: Vec<String>,
) -> anyhow::Result<()> {
    let issue_title = "Observability: Enum attributes can be improved";
    let mut markdown_header = markdown_header;
    markdown_header.push_str( 
        "This report was generated by [honey-health](https://github.com/jerbly/honey-health). \
                The table shows enum columns found in the dataset with variants undefined in semantic conventions. \
                This _could_ be an indication of data quality issues.\n\n\
                Enums defined with `allow_custom_values` are reported as warnings. These warnings should be checked - mistakes with \
                casing or typos can lead to incorrect variants.\n\n\
                _Note: If the report is too large, it will been split into multiple comments._\n\n");

    create_table_issue(
        repo_owner,
        repo_name,
        markdown_header,
        markdown_rows,
        issue_title,
    )
    .await
}

/// Given a list of markdown rows, create a GitHub issue in the provided repository.
/// The markdown rows will be split over multiple comments because of the maximum
/// comment length limit of 65536 characters.
async fn create_table_issue(
    repo_owner: &str,
    repo_name: &str,
    markdown_header: String,
    markdown_rows: Vec<String>,
    issue_title: &str,
) -> anyhow::Result<()> {
    if markdown_rows.len() < 2 {
        return Ok(());
    }
    // Capture the top two rows for the repeated table header
    let mut table_header = markdown_rows[0].clone();
    table_header.push('\n');
    table_header.push_str(&markdown_rows[1]);
    table_header.push('\n');

    let mut issue_body = markdown_header;

    let mut issue_number = None;

    for row in markdown_rows {
        if issue_body.len() + row.len() > 60000 {
            match issue_number {
                Some(number) => {
                    issue_body.insert_str(0, &table_header);
                    add_comment_to_github_issue(repo_owner, repo_name, number, &issue_body).await?;
                }
                None => {
                    let issue =
                        create_github_issue(repo_owner, repo_name, issue_title, &issue_body)
                            .await?;
                    issue_number = Some(issue.number);
                }
            }
            issue_body = row;
            issue_body.push('\n');
        } else {
            issue_body.push_str(&row);
            issue_body.push('\n');
        }
    }
    if !issue_body.is_empty() {
        match issue_number {
            Some(number) => {
                issue_body.insert_str(0, &table_header);
                add_comment_to_github_issue(repo_owner, repo_name, number, &issue_body).await?;
            }
            None => {
                create_github_issue(repo_owner, repo_name, issue_title, &issue_body).await?;
            }
        }
    }

    Ok(())
}

async fn create_github_issue(
    repo_owner: &str,
    repo_name: &str,
    issue_title: &str,
    issue_body: &str,
) -> anyhow::Result<Issue> {
    let token = env::var("GITHUB_TOKEN")?;
    let octocrab = Octocrab::builder().personal_token(token).build()?;

    let issue = octocrab
        .issues(repo_owner, repo_name)
        .create(issue_title)
        .body(issue_body)
        .labels(vec![String::from("observability")])
        .send()
        .await?;

    println!("Created issue: {}", issue.html_url);

    Ok(issue)
}

async fn add_comment_to_github_issue(
    repo_owner: &str,
    repo_name: &str,
    issue_number: u64,
    comment_body: &str,
) -> anyhow::Result<()> {
    let token = env::var("GITHUB_TOKEN")?;
    let octocrab = Octocrab::builder().personal_token(token).build()?;

    let comment = octocrab
        .issues(repo_owner, repo_name)
        .create_comment(issue_number, comment_body)
        .await?;

    println!("Created comment: {}", comment.html_url);

    Ok(())
}
